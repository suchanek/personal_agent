# pylint: disable=C0301,C0116
# ,C0115,W0613,E0611,C0413,E0401,W0601,W0621,C0302,E1101,C0103,W0718

import asyncio
import json
import logging
import subprocess
import time
import warnings
import threading
from datetime import datetime
from typing import Any, Dict, List, Optional

import requests
import weaviate.classes.config as wvc
from flask import Flask, render_template_string, request
from langchain.agents import AgentExecutor, create_react_agent
from langchain_core.prompts import PromptTemplate
from langchain_core.tools import tool
from langchain_ollama import ChatOllama, OllamaEmbeddings
from rich.logging import RichHandler
from urllib3.util import parse_url
from weaviate import WeaviateClient
from weaviate.connect import ConnectionParams
from weaviate.util import generate_uuid5

# Suppress Pydantic deprecation warnings from Ollama
warnings.filterwarnings("ignore", category=DeprecationWarning, module="ollama")
warnings.filterwarnings(
    "ignore", message=".*model_fields.*", category=DeprecationWarning
)

# Setup logging
logging.basicConfig(level=logging.INFO, handlers=[RichHandler()])
logger: logging.Logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Reduce httpx logging verbosity to WARNING to reduce noise
logging.getLogger("httpx").setLevel(logging.WARNING)


# Configuration
WEAVIATE_URL = "http://localhost:8080"
OLLAMA_URL = "http://localhost:11434"
USE_WEAVIATE = True  # Set to False to bypass Weaviate for testing
USE_MCP = True  # Set to False to bypass MCP for testing

# MCP Server configurations
MCP_SERVERS = {
    "filesystem": {
        "command": "npx",
        "args": ["@modelcontextprotocol/server-filesystem", "/Users/egs/repos"],
        "description": "Access filesystem operations",
    }
}


class MCPClient:
    """Thread-safe client for communicating with MCP servers."""

    def __init__(self, server_configs: Dict[str, Dict[str, Any]]):
        self.server_configs = server_configs
        self.active_servers = {}
        self.available_tools = {}
        self._loop = None
        self._thread = None
        self._start_thread()

    def _start_thread(self):
        """Start the async event loop in a separate thread."""
        def run_loop():
            self._loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self._loop)
            self._loop.run_forever()
        
        self._thread = threading.Thread(target=run_loop, daemon=True)
        self._thread.start()
        
        # Wait for loop to be ready
        while self._loop is None:
            time.sleep(0.01)

    def _run_async(self, coro):
        """Run an async function in the dedicated thread."""
        if self._loop is None:
            raise RuntimeError("Event loop not ready")
        
        future = asyncio.run_coroutine_threadsafe(coro, self._loop)
        return future.result(timeout=30)  # 30 second timeout

    async def start_server(self, server_name: str) -> bool:
        """Start an MCP server process."""
        if server_name not in self.server_configs:
            logger.error("Unknown MCP server: %s", server_name)
            return False

        config = self.server_configs[server_name]
        try:
            # Start the MCP server process
            process = await asyncio.create_subprocess_exec(
                *([config["command"]] + config["args"]),
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            self.active_servers[server_name] = {"process": process, "config": config}

            # Initialize and get available tools
            await self._initialize_server(server_name)
            logger.info("Started MCP server: %s", server_name)
            return True

        except Exception as e:
            logger.error("Failed to start MCP server %s: %s", server_name, e)
            return False

    async def _initialize_server(self, server_name: str):
        """Initialize server and get available tools."""
        try:
            # Send initialize request
            init_request = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "initialize",
                "params": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {"tools": {}},
                    "clientInfo": {"name": "personal-agent", "version": "0.1.0"},
                },
            }

            response = await self._send_request(server_name, init_request)
            if response and response.get("result"):
                # Get available tools
                tools_request = {"jsonrpc": "2.0", "id": 2, "method": "tools/list"}

                tools_response = await self._send_request(server_name, tools_request)
                if tools_response and tools_response.get("result"):
                    self.available_tools[server_name] = tools_response["result"].get(
                        "tools", []
                    )
                    logger.info(
                        "Initialized MCP server %s with %d tools",
                        server_name,
                        len(self.available_tools[server_name]),
                    )

        except Exception as e:
            logger.error("Failed to initialize MCP server %s: %s", server_name, e)

    async def _send_request(
        self, server_name: str, request: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Send a JSON-RPC request to an MCP server."""
        if server_name not in self.active_servers:
            return None

        try:
            process = self.active_servers[server_name]["process"]
            request_json = json.dumps(request) + "\n"

            # Send request
            process.stdin.write(request_json.encode())
            await process.stdin.drain()

            # Read response
            response_line = await process.stdout.readline()
            if response_line:
                return json.loads(response_line.decode().strip())

        except Exception as e:
            logger.error("Error sending request to MCP server %s: %s", server_name, e)

        return None

    async def call_tool(
        self, server_name: str, tool_name: str, arguments: Dict[str, Any]
    ) -> str:
        """Call a tool on an MCP server."""
        try:
            request = {
                "jsonrpc": "2.0",
                "id": 3,
                "method": "tools/call",
                "params": {"name": tool_name, "arguments": arguments},
            }

            response = await self._send_request(server_name, request)
            if response and response.get("result"):
                content = response["result"].get("content", [])
                if content and len(content) > 0:
                    return content[0].get("text", "No response")

        except Exception as e:
            logger.error(
                "Error calling tool %s on server %s: %s", tool_name, server_name, e
            )

        return f"Error calling tool {tool_name}"

    def call_tool_sync(self, server_name: str, tool_name: str, arguments: Dict[str, Any]) -> str:
        """Synchronous wrapper for calling MCP tools."""
        try:
            return self._run_async(self.call_tool(server_name, tool_name, arguments))
        except Exception as e:
            logger.error("Error in sync tool call: %s", e)
            return f"Error calling tool {tool_name}: {e}"

    def start_server_sync(self, server_name: str) -> bool:
        """Synchronous wrapper for starting MCP servers."""
        try:
            return self._run_async(self.start_server(server_name))
        except Exception as e:
            logger.error("Error starting server: %s", e)
            return False

    def stop_all_servers(self):
        """Stop all active MCP servers."""
        for server_name, server_info in self.active_servers.items():
            try:
                process = server_info["process"]
                process.terminate()
                logger.info("Stopped MCP server: %s", server_name)
            except Exception as e:
                logger.error("Error stopping MCP server %s: %s", server_name, e)

        self.active_servers.clear()
        
        # Stop the event loop
        if self._loop:
            self._loop.call_soon_threadsafe(self._loop.stop)


# Initialize MCP client
mcp_client = None
if USE_MCP:
    mcp_client = MCPClient(MCP_SERVERS)

# Initialize Flask app
app = Flask(__name__)

# Initialize Weaviate client and vector store
vector_store = None
weaviate_client = None
if USE_WEAVIATE:
    try:
        # Verify Weaviate is running with retries
        for attempt in range(5):
            logger.info(
                "Attempting to connect to Weaviate at %s (attempt %d/5)",
                WEAVIATE_URL,
                attempt + 1,
            )
            response = requests.get(f"{WEAVIATE_URL}/v1/.well-known/ready", timeout=10)
            if response.status_code == 200:
                logger.info("Weaviate is ready")
                break
            else:
                raise RuntimeError(f"Weaviate returned status {response.status_code}")
    except requests.exceptions.RequestException as e:
        logger.error("Attempt %d/5: Error connecting to Weaviate: %s", attempt + 1, e)
        if attempt == 4:
            logger.error(
                "Cannot connect to Weaviate at %s, proceeding without Weaviate",
                WEAVIATE_URL,
            )
            USE_WEAVIATE = False
        time.sleep(10)

    if USE_WEAVIATE:
        # Parse WEAVIATE_URL to create ConnectionParams
        parsed_url = parse_url(WEAVIATE_URL)
        connection_params = ConnectionParams.from_params(
            http_host=parsed_url.host or "localhost",
            http_port=parsed_url.port or 8080,
            http_secure=parsed_url.scheme == "https",
            grpc_host=parsed_url.host or "localhost",
            grpc_port=50051,  # Weaviate's default gRPC port
            grpc_secure=parsed_url.scheme == "https",
        )

        # Initialize Weaviate client
        try:
            weaviate_client = WeaviateClient(connection_params, skip_init_checks=True)
            weaviate_client.connect()  # Explicitly connect
            collection_name = "UserKnowledgeBase"

            # Create Weaviate collection if it doesn't exist
            if not weaviate_client.collections.exists(collection_name):
                logger.info("Creating Weaviate collection: %s", collection_name)
                weaviate_client.collections.create(
                    name=collection_name,
                    properties=[
                        wvc.Property(name="text", data_type=wvc.DataType.TEXT),
                        wvc.Property(name="timestamp", data_type=wvc.DataType.DATE),
                        wvc.Property(name="topic", data_type=wvc.DataType.TEXT),
                    ],
                    vectorizer_config=wvc.Configure.Vectorizer.none(),
                )
        except ImportError as e:
            logger.error(
                "Import error initializing Weaviate client or collection: %s", e
            )
            USE_WEAVIATE = False
        except AttributeError as e:
            logger.error(
                "Attribute error initializing Weaviate client or collection: %s", e
            )
            USE_WEAVIATE = False
        except Exception as e:
            logger.error(
                "Unexpected error initializing Weaviate client or collection: %s", e
            )
            USE_WEAVIATE = False

        if USE_WEAVIATE:
            # Initialize Weaviate vector store
            from langchain_weaviate import WeaviateVectorStore

            vector_store = WeaviateVectorStore(
                client=weaviate_client,
                index_name=collection_name,
                text_key="text",
                embedding=OllamaEmbeddings(
                    model="nomic-embed-text", base_url=OLLAMA_URL
                ),
                attributes=["timestamp", "topic"],
            )

# Initialize Ollama LLM
llm = ChatOllama(model="qwen2.5:7b-instruct", temperature=0.7, base_url=OLLAMA_URL)


# Define tools
@tool
def store_interaction(text: str, topic: str = "general") -> str:
    """Store user interaction in Weaviate."""
    if not USE_WEAVIATE or vector_store is None:
        logger.warning("Weaviate is disabled, interaction not stored.")
        return "Weaviate is disabled, interaction not stored."
    try:
        # Format timestamp as RFC3339 (with 'Z' for UTC)
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")
        vector_store.add_texts(
            texts=[text],
            metadatas=[{"timestamp": timestamp, "topic": topic}],
            ids=[generate_uuid5(text)],
        )
        logger.info("Stored interaction: %s...", text[:50])
        return "Interaction stored successfully."
    except Exception as e:
        logger.error("Error storing interaction: %s", str(e))
        return f"Error storing interaction: {str(e)}"


@tool
def query_knowledge_base(query: str, limit: int = 5) -> List[str]:
    """Query Weaviate for relevant context."""
    if not USE_WEAVIATE or vector_store is None:
        logger.warning("Weaviate is disabled, no context available.")
        return ["Weaviate is disabled, no context available."]
    try:
        results = vector_store.similarity_search(query, k=limit)
        logger.info("Queried knowledge base with: %s...", query[:50])
        return (
            [doc.page_content for doc in results]
            if results
            else ["No relevant context found."]
        )
    except Exception as e:
        logger.error("Error querying knowledge base: %s", str(e))
        return [f"Error querying knowledge base: {str(e)}"]


@tool
def clear_knowledge_base() -> str:
    """Clear all data from the knowledge base."""
    if not USE_WEAVIATE or weaviate_client is None:
        logger.warning("Weaviate is disabled, cannot clear knowledge base.")
        return "Weaviate is disabled, cannot clear knowledge base."
    try:
        collection_name = "UserKnowledgeBase"
        collection = weaviate_client.collections.get(collection_name)

        # Delete all objects in the collection using a different approach
        try:
            # First, try to delete with an empty where clause
            result = collection.data.delete_many(where={})
            deleted_count = result.successful if hasattr(result, "successful") else 0
        except Exception as delete_error:
            logger.warning(
                "delete_many failed, trying alternative approach: %s", delete_error
            )
            # Alternative: Get all objects and delete them individually
            try:
                # Get all object UUIDs
                objects = collection.query.fetch_objects(limit=10000)
                deleted_count = 0
                for obj in objects.objects:
                    try:
                        collection.data.delete_by_id(obj.uuid)
                        deleted_count += 1
                    except Exception as individual_delete_error:
                        logger.warning(
                            "Failed to delete object %s: %s",
                            obj.uuid,
                            individual_delete_error,
                        )
            except Exception as fetch_error:
                logger.error("Failed to fetch objects for deletion: %s", fetch_error)
                # Last resort: recreate the collection
                try:
                    weaviate_client.collections.delete(collection_name)
                    # Recreate the collection
                    import weaviate.classes.config as wvc

                    weaviate_client.collections.create(
                        name=collection_name,
                        properties=[
                            wvc.Property(name="text", data_type=wvc.DataType.TEXT),
                            wvc.Property(name="timestamp", data_type=wvc.DataType.DATE),
                            wvc.Property(name="topic", data_type=wvc.DataType.TEXT),
                        ],
                        vectorizer_config=wvc.Configure.Vectorizer.none(),
                    )
                    deleted_count = "all (collection recreated)"
                    logger.info("Recreated collection %s", collection_name)
                except Exception as recreate_error:
                    logger.error("Failed to recreate collection: %s", recreate_error)
                    return f"Error clearing knowledge base: {recreate_error}"

        logger.info("Cleared knowledge base. Deleted objects: %s", deleted_count)
        return f"Knowledge base cleared successfully. Deleted {deleted_count} objects."
    except Exception as e:
        logger.error("Error clearing knowledge base: %s", str(e))
        return f"Error clearing knowledge base: {str(e)}"


# MCP-based tools
@tool
def mcp_read_file(file_path: str) -> str:
    """Read file content using MCP filesystem server."""
    if not USE_MCP or mcp_client is None:
        return "MCP is disabled, cannot read file."

    try:
        # Start filesystem server if not already running
        if "filesystem" not in mcp_client.active_servers:
            start_result = mcp_client.start_server_sync("filesystem")
            if not start_result:
                return "Failed to start MCP filesystem server."

        # Expand home directory path
        if file_path.startswith("~/"):
            file_path = file_path.replace("~/", "/Users/egs/")
        
        # Call read_file tool with correct parameter name
        result = mcp_client.call_tool_sync("filesystem", "read_file", {"path": file_path})

        # Store the file read operation in memory for context
        if USE_WEAVIATE and vector_store is not None:
            interaction_text = (
                f"Read file: {file_path}\nContent preview: {result[:200]}..."
            )
            store_interaction.invoke(
                {"text": interaction_text, "topic": "file_operations"}
            )

        logger.info("Read file via MCP: %s", file_path)
        return result

    except Exception as e:
        logger.error("Error reading file via MCP: %s", str(e))
        return f"Error reading file: {str(e)}"


@tool
def mcp_write_file(file_path: str, content: str) -> str:
    """Write content to file using MCP filesystem server."""
    if not USE_MCP or mcp_client is None:
        return "MCP is disabled, cannot write file."

    try:
        # Start filesystem server if not already running
        if "filesystem" not in mcp_client.active_servers:
            start_result = mcp_client.start_server_sync("filesystem")
            if not start_result:
                return "Failed to start MCP filesystem server."

        # Expand home directory path
        if file_path.startswith("~/"):
            file_path = file_path.replace("~/", "/Users/egs/")
        
        # Call write_file tool with correct parameter name
        result = mcp_client.call_tool_sync(
            "filesystem", "write_file", {"path": file_path, "contents": content}
        )

        # Store the file write operation in memory for context
        if USE_WEAVIATE and vector_store is not None:
            interaction_text = (
                f"Wrote file: {file_path}\nContent length: {len(content)} characters"
            )
            store_interaction.invoke(
                {"text": interaction_text, "topic": "file_operations"}
            )

        logger.info("Wrote file via MCP: %s", file_path)
        return result

    except Exception as e:
        logger.error("Error writing file via MCP: %s", str(e))
        return f"Error writing file: {str(e)}"


@tool
def mcp_list_directory(directory_path: str) -> str:
    """List directory contents using MCP filesystem server."""
    if not USE_MCP or mcp_client is None:
        return "MCP is disabled, cannot list directory."

    try:
        # Start filesystem server if not already running
        if "filesystem" not in mcp_client.active_servers:
            start_result = mcp_client.start_server_sync("filesystem")
            if not start_result:
                return "Failed to start MCP filesystem server."

        # Expand home directory path
        if directory_path.startswith("~/"):
            directory_path = directory_path.replace("~/", "/Users/egs/")
        
        # Call list_directory tool
        result = mcp_client.call_tool_sync(
            "filesystem", "list_directory", {"path": directory_path}
        )

        # Store the directory listing operation in memory for context
        if USE_WEAVIATE and vector_store is not None:
            interaction_text = (
                f"Listed directory: {directory_path}\nResult: {result[:300]}..."
            )
            store_interaction.invoke(
                {"text": interaction_text, "topic": "file_operations"}
            )

        logger.info("Listed directory via MCP: %s", directory_path)
        return result

    except Exception as e:
        logger.error("Error listing directory via MCP: %s", str(e))
        return f"Error listing directory: {str(e)}"


@tool
def intelligent_file_search(
    search_query: str, directory: str = "/Users/egs/repos"
) -> str:
    """Search for files and enhance results with memory context."""
    if not USE_MCP or mcp_client is None:
        return "MCP is disabled, cannot search files."

    try:
        # First, search memory for relevant context
        memory_context = []
        if USE_WEAVIATE and vector_store is not None:
            memory_results = query_knowledge_base.invoke(
                {"query": search_query, "limit": 3}
            )
            memory_context = (
                memory_results
                if memory_results != ["No relevant context found."]
                else []
            )

        # Use MCP to list directory contents and search for relevant files
        directory_listing = mcp_list_directory(directory)

        # Use LLM to analyze which files might be relevant based on the search query
        analysis_prompt = f"""
        Based on the search query: "{search_query}"
        
        Directory listing: {directory_listing}
        
        Memory context: {memory_context}
        
        Which files in this directory are most relevant to the search query? 
        Provide a focused analysis and suggest the top 2-3 most relevant files to examine.
        """

        # Store this search operation in memory
        if USE_WEAVIATE and vector_store is not None:
            interaction_text = f"File search: {search_query} in {directory}\nFound: {directory_listing[:200]}..."
            store_interaction.invoke({"text": interaction_text, "topic": "file_search"})

        logger.info("Performed intelligent file search: %s", search_query)
        return f"Directory contents: {directory_listing}\n\nMemory context: {memory_context}\n\nAnalysis needed: {analysis_prompt}"

    except Exception as e:
        logger.error("Error in intelligent file search: %s", str(e))
        return f"Error searching files: {str(e)}"


# Define system prompt for the agent
system_prompt = PromptTemplate(
    template="""You are a helpful personal assistant named "Personal Agent" that learns about the user and provides context-aware responses.

You have access to these tools:
{tools}

Tool names: {tool_names}

IMPORTANT INSTRUCTIONS:
1. ALWAYS respond to the user's current question/request first
2. Use the context from knowledge base to enhance your response when relevant
3. Store important interactions for future reference
4. Be conversational and helpful
5. Use MCP filesystem tools to read, write, and analyze files when requested
6. Combine file operations with memory storage for enhanced context

CAPABILITIES:
- Memory: Store and query interactions using Weaviate vector database
- File Operations: Read, write, list files using MCP filesystem server
- Intelligent Search: Combine file system exploration with memory context
- Learning: Automatically store important file operations for future reference

Current context from knowledge base: {context}

User's current input: {input}

To use a tool, follow this exact format:
Thought: I need to [reason for using tool]
Action: [exact tool name from: {tool_names}]
Action Input: {{"param": "value"}}
Observation: [tool result will appear here]

When you have enough information, provide your final answer:
Thought: I can now answer the user's question
Final Answer: [your complete response to the user's current input]

Remember: Answer the user's CURRENT question first, then optionally use context to enhance your response.

{agent_scratchpad}""",
    input_variables=["input", "context", "tool_names", "tools", "agent_scratchpad"],
)

# Initialize ReAct agent
tools = [
    store_interaction,
    query_knowledge_base,
    clear_knowledge_base,
    mcp_read_file,
    mcp_write_file,
    mcp_list_directory,
    intelligent_file_search,
]
agent = create_react_agent(llm=llm, tools=tools, prompt=system_prompt)
agent_executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,
    handle_parsing_errors=True,
    max_iterations=3,
)


# Flask routes
@app.route("/", methods=["GET", "POST"])
def index():
    response = None
    context = None
    if request.method == "POST":
        user_input = request.form.get("query", "")
        topic = request.form.get("topic", "general")
        if user_input:
            # Query knowledge base for context
            try:
                # Call the function directly with proper parameters
                context = query_knowledge_base.invoke({"query": user_input, "limit": 5})
                context_str = (
                    "\n".join(context) if context else "No relevant context found."
                )
                # Generate response
                result = agent_executor.invoke(
                    {"input": user_input, "context": context_str}
                )
                if isinstance(result, dict):
                    response = result.get("output", "No response generated.")
                else:
                    response = str(result)
                # Store interaction AFTER getting response
                interaction_text = f"User: {user_input}\nAssistant: {response}"
                store_interaction.invoke({"text": interaction_text, "topic": topic})
            except Exception as e:
                logger.error("Error processing query: %s", str(e))
                response = f"Error processing query: {str(e)}"
            logger.info(
                "Received query: %s..., Response: %s...",
                user_input[:50],
                response[:50],
            )
    return render_template_string(
        """
        <html>
            <head>
                <title>Personal AI Agent</title>
                <style>
                    body { font-family: Arial, sans-serif; margin: 20px; }
                    h1 { color: #333; }
                    textarea, input[type="text"] { width: 100%; max-width: 600px; }
                    input[type="submit"] { margin-top: 10px; padding: 10px 20px; }
                    .reset-btn { margin-left: 10px; padding: 10px 20px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; }
                    .reset-btn:hover { background-color: #c82333; }
                    .response, .context { margin-top: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
                    .context { background-color: #f9f9f9; }
                    .context ul { list-style-type: none; padding: 0; }
                    .success-message { margin-top: 20px; padding: 10px; background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; color: #155724; }
                </style>
            </head>
            <body>
                <h1>Personal AI Agent</h1>
                <form method="post">
                    <label for="query">Query:</label><br>
                    <textarea name="query" rows="5" cols="50" placeholder="Ask me anything..."></textarea><br>
                    <label for="topic">Topic:</label><br>
                    <input type="text" name="topic" value="general" placeholder="e.g., programming, personal, etc."><br>
                    <input type="submit" value="Submit">
                    <button type="button" class="reset-btn" onclick="if(confirm('Are you sure you want to clear all stored knowledge? This action cannot be undone.')) { window.location.href='/clear'; }">Reset Knowledge Base</button>
                </form>
                {% if response %}
                    <div class="response">
                        <h2>Response:</h2>
                        <p style="white-space: pre-wrap;">{{ response }}</p>
                    </div>
                {% endif %}
                {% if context and context != ['No relevant context found.'] %}
                    <div class="context">
                        <h2>Context Used:</h2>
                        <ul>
                        {% for item in context %}
                            <li style="margin: 5px 0; padding: 5px; background: #f0f0f0; border-radius: 3px;">{{ item }}</li>
                        {% endfor %}
                        </ul>
                    </div>
                {% endif %}
            </body>
        </html>
        """,
        response=response,
        context=context,
    )


@app.route("/clear")
def clear_kb():
    """Route to clear the knowledge base."""
    try:
        result = clear_knowledge_base.invoke({})
        logger.info("Knowledge base cleared via web interface: %s", result)
        return render_template_string(
            """
            <html>
                <head>
                    <title>Personal AI Agent - Knowledge Base Cleared</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1 { color: #333; }
                        .success-message { margin-top: 20px; padding: 10px; background-color: #d4edda; border: 1px solid #c3e6cb; border-radius: 5px; color: #155724; }
                        .back-btn { margin-top: 20px; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; display: inline-block; }
                        .back-btn:hover { background-color: #0056b3; }
                    </style>
                </head>
                <body>
                    <h1>Personal AI Agent</h1>
                    <div class="success-message">
                        <strong>Success!</strong> {{ result }}
                    </div>
                    <a href="/" class="back-btn">Back to Agent</a>
                </body>
            </html>
            """,
            result=result,
        )
    except Exception as e:
        logger.error("Error clearing knowledge base via web interface: %s", str(e))
        return render_template_string(
            """
            <html>
                <head>
                    <title>Personal AI Agent - Error</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        h1 { color: #333; }
                        .error-message { margin-top: 20px; padding: 10px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 5px; color: #721c24; }
                        .back-btn { margin-top: 20px; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; display: inline-block; }
                        .back-btn:hover { background-color: #0056b3; }
                    </style>
                </head>
                <body>
                    <h1>Personal AI Agent</h1>
                    <div class="error-message">
                        <strong>Error!</strong> Failed to clear knowledge base: {{ error }}
                    </div>
                    <a href="/" class="back-btn">Back to Agent</a>
                </body>
            </html>
            """,
            error=str(e),
        )


def cleanup():
    """Clean up resources on shutdown."""
    global weaviate_client, mcp_client

    # Clean up MCP servers
    if mcp_client:
        try:
            mcp_client.stop_all_servers()
            logger.info("MCP servers stopped successfully")
        except Exception as e:
            logger.error("Error stopping MCP servers: %s", e)

    # Clean up Weaviate client
    if weaviate_client:
        try:
            weaviate_client.close()
            logger.info("Weaviate client closed successfully")
        except Exception as e:
            logger.error("Error closing Weaviate client: %s", e)


if __name__ == "__main__":
    import atexit

    atexit.register(cleanup)
    try:
        app.run(host="127.0.0.1", port=5000, debug=True)
    except KeyboardInterrupt:
        cleanup()
